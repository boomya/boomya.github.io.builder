title: 算法复杂度
date: 2014-12-30 22:16:55
categories: 算法
tags: ['算法', '时间复杂度']
description:
---
算法复杂度, 时间复杂度和空间复杂度
<!--more-->
算法复杂度, 时间复杂度和空间复杂度
时间复杂度
--------
- ####理论   
  **我们只需要知道比较两个算法,哪个算法运行的时间长或者短就可以,不需要知道多多少,也不需要知道具体的运行时间是多少.**  
  一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。
T(n) = Ο(f(n)) 表示存在一个常数C，使得在当n趋于正无穷时总有 T(n) ≤ C \* f(n)。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时T(n)的上界是C \* f(n)。  
  f(n)只取最高次幂项, O(2n^2 +n +1) = (7n^2 + n) = O(n^2)  
  如果把T(n)当做一棵树，那么O(f(n))所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。  
  若算法中语句执行次数为一个常数，则时间复杂度为O(1).  
  在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。  
  按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n^2)，立方阶O(n^3),...， k次方阶O(n^k),指数阶O(2^n)。  
  **常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n^2)＜Ο(n^3)＜…＜Ο(2^n)＜Ο(n!)**  
  Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n^2)和Ο(n^3)称为多项式时间，而Ο(2^n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为P（Polynomial,多项式）类问题，而把后者（即指数时间复杂度的算法）称为NP（Non-Deterministic Polynomial, 非确定多项式）问题。  
  
- ####如何计算时间复杂度  
	1. 找出算法中的基本语句；  
算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。    
	2. 计算基本语句的执行次数的数量级；  
只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。  
	3. 用大O记号表示算法的时间性能。  
将基本语句执行次数的数量级放入大Ο记号中。  
 
例
```java
　　for (i=1; i<=n; i++)  
　　       x++;  
　　for (i=1; i<=n; i++)    
　     　for (j=1; j<=n; j++)  
　　          x++; 
```   
如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。
第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n^2)，则整个算法的时间复杂度为Ο(n+n^2)=Ο(n^2)。

- ####几个简单的分析法则
	1. 对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间
	2. 对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下"求和法则"
	**求和法则:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n)))  
	特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))**
	3. 对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间
	4. 对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下"乘法法则"  
	**乘法法则: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1\*T2=O(f(n)\*g(n))**
	5. 对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度  
	**另外:若g(n)=O(f(n)),则O(f(n))+ O(g(n))=O(f(n))**
	
- ####时间复杂度示例 

O(1)
~~~java
Temp=i; i=j; j=temp; 
~~~
如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。

O(n)
~~~java
 a=0;
    b=1;              	(1次)
    for (i=1;i<=n;i++) 	(n次)
    {  
       s=a+b;　　　　	(n次)
       b=a;　　　　　	(n次) 
       a=s;　　　　　	(n次)
    }
~~~
T(n)=1+4n=O(n).

O(n^2)
~~~java
    sum=0；                 （1次）
     for(i=1;i<=n;i++)     （n次）
        for(j=1;j<=n;j++) （n^2次）
         sum++；            （n^2次）
~~~
总的循环次数为0+1+2+...+(n-1)=n(n-1)/2
去低阶项，去掉常数项，去掉高阶项的常参得到，所以T(n)=O(n^2)；

O(log2n)
~~~java
    i=1;     (1次)
    while (i<=n)
       i=i*2; (如果频度是m,则2^m>n时退出循环,也就是m=log2n)
~~~
取最大值f(n)=log2n, T(n)=O(log2n)

O(n^3)
~~~java
for(i=0;i<n;i++)
    {  
       for(j=0;j<i;j++)  
       {
          for(k=0;k<j;k++)
             x=x+2;  
       }
    }
~~~ 
当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n3).

算法的空间复杂度
--------------
类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。
空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。