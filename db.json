{"Asset":[{"_id":"themes/nut/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":false},{"_id":"themes/nut/source/js/jquery.fitvids.js","path":"js/jquery.fitvids.js","modified":false},{"_id":"themes/nut/source/js/script.js","path":"js/script.js","modified":false},{"_id":"themes/nut/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":false},{"_id":"themes/nut/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":false},{"_id":"themes/nut/source/css/style.styl","path":"css/style.styl","modified":false},{"_id":"themes/nut/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":false},{"_id":"themes/nut/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":false},{"_id":"themes/nut/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":false},{"_id":"themes/nut/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":false},{"_id":"themes/nut/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":false},{"_id":"themes/nut/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":false},{"_id":"themes/nut/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":false},{"_id":"themes/nut/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":false},{"_id":"themes/nut/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":false},{"_id":"themes/nut/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":false},{"_id":"themes/nut/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":false},{"_id":"themes/nut/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":false},{"_id":"themes/nut/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":false},{"_id":"themes/nut/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":false},{"_id":"themes/nut/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":false},{"_id":"themes/nut/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":false},{"_id":"themes/nut/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":false},{"_id":"themes/nut/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":false},{"_id":"themes/nut/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":false},{"_id":"themes/nut/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":false}],"Cache":[{"_id":"scaffolds/draft.md","mtime":1407586169000},{"_id":"scaffolds/page.md","mtime":1407586169000},{"_id":"scaffolds/photo.md","mtime":1407586169000},{"_id":"scaffolds/post.md","mtime":1407591163000},{"_id":"source/_posts/jdk-arraylist.md","mtime":1407673860000},{"_id":"source/about/index.md","mtime":1407588436000},{"_id":"themes/nut/Gruntfile.js","mtime":1407673193000},{"_id":"themes/nut/LICENSE","mtime":1407673193000},{"_id":"themes/nut/README.md","mtime":1407673193000},{"_id":"themes/nut/_config.yml","mtime":1407673193000},{"_id":"themes/nut/package.json","mtime":1407673193000},{"_id":"themes/nut/scripts/extend.generator.js","mtime":1407673193000},{"_id":"themes/nut/scripts/extend.helper.js","mtime":1407673193000},{"_id":"themes/nut/scripts/extend.renderer.js","mtime":1407673193000},{"_id":"themes/nut/scripts/extend.tag.js","mtime":1407673193000},{"_id":"themes/nut/scripts/fancybox.js","mtime":1407673193000},{"_id":"themes/nut/layout/archive.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/category.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/index.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/layout.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/page.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/post.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/tag.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/wiki.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_widget/archive.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_widget/blogroll.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_widget/category.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_widget/nav.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_widget/post_category.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_widget/post_date.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_widget/post_tag.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_widget/recent_posts.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_widget/search.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_widget/tag.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_widget/tagcloud.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/after-footer.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/archive-post.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/article.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/archive.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/category.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/footer.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/google-analytics.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/head.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/mobile-nav.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/header.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/sidebar.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/tag.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/wiki-toc.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/wiki.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/post/category.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/post/date.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/post/gallery.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/post/nav.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/post/tag.ejs","mtime":1407673193000},{"_id":"themes/nut/layout/_partial/post/title.ejs","mtime":1407673193000},{"_id":"themes/nut/source/js/bootstrap.min.js","mtime":1407673193000},{"_id":"themes/nut/source/js/jquery.fitvids.js","mtime":1407673193000},{"_id":"themes/nut/source/js/script.js","mtime":1407673193000},{"_id":"themes/nut/source/css/_extend.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_variables.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/bootstrap.min.css","mtime":1407673193000},{"_id":"themes/nut/source/css/font-awesome.min.css","mtime":1407673193000},{"_id":"themes/nut/source/css/style.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/archive.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/article.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/cat-tag.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/comment.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/footer.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/header.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/highlight.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/mobile.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/sidebar-aside.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/sidebar-bottom.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/sidebar.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_partial/wiki.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_util/grid.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/_util/mixin.styl","mtime":1407673193000},{"_id":"themes/nut/source/css/fonts/FontAwesome.otf","mtime":1407673193000},{"_id":"themes/nut/source/css/fonts/fontawesome-webfont.eot","mtime":1407673193000},{"_id":"themes/nut/source/css/fonts/fontawesome-webfont.svg","mtime":1407673193000},{"_id":"themes/nut/source/css/fonts/fontawesome-webfont.ttf","mtime":1407673193000},{"_id":"themes/nut/source/css/fonts/fontawesome-webfont.woff","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/blank.gif","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/fancybox_loading.gif","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/fancybox_loading@2x.gif","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/fancybox_overlay.png","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/fancybox_sprite.png","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/fancybox_sprite@2x.png","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/jquery.fancybox.css","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/jquery.fancybox.js","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/jquery.fancybox.pack.js","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/helpers/fancybox_buttons.png","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/helpers/jquery.fancybox-buttons.css","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/helpers/jquery.fancybox-buttons.js","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/helpers/jquery.fancybox-media.js","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/helpers/jquery.fancybox-thumbs.css","mtime":1407673193000},{"_id":"themes/nut/source/fancybox/helpers/jquery.fancybox-thumbs.js","mtime":1407673193000},{"_id":"source/_posts/jdk-hashmap.md","mtime":1407675224000},{"_id":"source/_posts/jvm-debug.md","mtime":1407675803000},{"_id":"source/_posts/synchronized.md","mtime":1407676355000},{"_id":"source/_posts/git-beginner.md","mtime":1407741065000},{"_id":"source/_posts/data-structure-tree-basic.md","mtime":1413888268000},{"_id":"source/_posts/linux-basic-command.md","mtime":1419844984000},{"_id":"source/_posts/zhenyan.md","mtime":1419844965000},{"_id":"source/_posts/2014-books.md","mtime":1419859408000}],"Category":[{"name":"JDK源码","_id":"aidwn3fgrekq2svq","posts":["c5e3zeatuomrjnk1","m1tek6xoz1gh6t9a"]},{"name":"debug","_id":"5w4csv955ihnptcs","posts":["2dg1cnc7qirpwv2z"]},{"name":"java","_id":"o21o0hv3f03hdic4","posts":["c2g2vyr66rge2l1o"]},{"name":"git","_id":"ldtfzc8g3ibrgv87","posts":["msxa3ng45s6qx6eq"]},{"name":"数据结构","_id":"qrcv19hmxcf2i3as","posts":["f9f0q2bjn5a7jc3n"]},{"name":"linux","_id":"5g0484d7oash73he","posts":["kpmeb3fnsx1fm3wl"]},{"name":"other","_id":"uuf685eign7h5noh","posts":["vlqynib06xh6tpu9"]},{"name":"book","_id":"rkc7hxpno7dbhfbc","posts":["9syodqumwlg1ket0"]}],"Page":[{"title":"about","date":1407587648000,"content":"<h4 id=\"超人不会飞\">超人不会飞</h4><h5 id=\"coder.jiangshan@gmail.com\">coder.jiangshan@gmail.com</h5>","source":"about/index.md","raw":"title: about\ndate: 2014-08-09 20:34:08\n---\n####超人不会飞  \n#####coder.jiangshan@gmail.com  ","updated":1407588436000,"path":"about/index.html","excerpt":"","_id":"p2cswnctcmrm3206","comments":true,"layout":"page"}],"Post":[{"title":"JDK-ArrayList","date":1407589173000,"categories":["aidwn3fgrekq2svq"],"tags":["sj2ttyeugxvwc2gl","pbsree1n4e3x1qlf"],"description":"ArrayList 是最常用的容器类,内部实现是看名字就知道是用的数组,一直再用从来没有看过内部的实现细节,今天学习一下.","content":"<p>ArrayList 是最常用的容器类,内部实现是看名字就知道是用的数组,一直再用从来没有看过内部的实现细节,今天学习一下.\n<a id=\"more\"></a>\n<em>ArrayList</em> 是最常用的容器类,内部实现是看名字就知道是用的数组,一直再用从来没有看过内部的实现细节,今天学习一下.\n打开 <em>ArrayList</em> 最开始的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>\n\n<p>果然是通过数组来保存数据.<br><strong>transient</strong> 是指明这个变量不要被序列化.</p>\n<h3 id=\"1.关于遍历\">1.关于遍历</h3><p>常用的遍历的方法就是创建迭代器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Iterator&lt;String&gt; it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext()){</div><div class=\"line\">    String s = it.next();</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n\n<p>还有一种迭代器 <em>ListIterator</em> ,他继承了 <em>Iterator</em> ,除了有常规迭代器的方法还有 <em>hasPrevious()</em> 和 <em>previous()</em> 方法,提供了向前遍历.</p>\n<h3 id=\"2.concurrentmodificationexception\">2.ConcurrentModificationException</h3><p>在操作 <em>ArrayList</em> 时经常会发生 <em>ConcurrentModificationException</em> ,比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Iterator&lt;String&gt; it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext()){</div><div class=\"line\">    String s = it.next();</div><div class=\"line\">    list.remove(s); <span class=\"comment\">//list.add(s);</span></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>在遍历 <em>ArrayList</em> 过程中执行移除或添加的操作就会抛出 <em>ConcurrentModificationException</em> .在 <em>ArrayList</em> 在父类 <em>AbstractList</em> 有一个变量 <em>modCount</em> ,这个值在 <em>ArrayList</em> 执行移除或者添加方法时会执行 <em>modCount++</em> 操作,在创建迭代器时 <code>Iterator&lt;String&gt; it = list.iterator();</code> 会把 <em>modCount</em> 传入到迭代器中并保存一份副本 <code>int expectedModCount = modCount;</code>,迭代器在遍历过程中调用 <em>next()</em> 方法时会执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> checkForComodification() {</div><div class=\"line\">\t<span class=\"keyword\">if</span> (modCount != expectedModCount)</div><div class=\"line\">\t    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</div><div class=\"line\">    }</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>因为在遍历过程中执行了移除或者添加方法,改变了 <em>modCount</em> 的值,所以 <em>modCount</em> 和 <em>expectedModCount</em> 不匹配,抛出 <em>ConcurrentModificationException</em> .<br>解决方案:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Iterator&lt;String&gt; it = list.iterator();</div><div class=\"line\"><span class=\"keyword\">while</span>(it.hasNext()){</div><div class=\"line\">    String s = it.next();</div><div class=\"line\">    it.remove(); </div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>将移除方法改为迭代器的移除方法,就不会抛出异常,因为 <em>it.remove()</em> 是通过当前的索引移除,并且在移除后会用最新的 <em>modCount</em> 更新 <em>expectedModCount</em> ,所以不会抛出异常.\n还有一种解决方案,是在遍历过程中将需要移除掉的元素保存到一个临时的ArrayList中,在遍历完成后,执行 <em>removeAll</em> 方法. </p>\n<h3 id=\"3.自动扩容\">3.自动扩容</h3><p>ArrayList是没有长度限制的,但是他内部的存储结构是数组,数组是需要固定长度的.ArrayList在添加一个元素的时候会判断是否已经大于当前数组的长度,如果大于,会创建一个新的数组,长度是当前数组长度的1.5倍,再将当前数据复制到新数组中.  </p>\n<h3 id=\"4.unsupportedoperationexception\">4.UnsupportedOperationException</h3><p>UnsupportedOperationException这个异常也很常见,在 <em>ArrayList</em> 的父类 <em>AbstractList</em> 定义了很多方法,方法体就是抛出 <em>UnsupportedOperationException</em> ,如果子类没有重写这个方法,调用的时候就会抛出这个异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span>(<span class=\"keyword\">int</span> index) {</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>这更像是一种编程技巧,可能会有这样一种场景,多个子类继承同一个父类,而子类之间的行为有可能不是全部相同或者说全部支持,通过上面这种方式处理,约定好一种 <em>exception</em> ,处理起来更加的优雅,易理解.</p>\n","source":"_posts/jdk-arraylist.md","raw":"title: JDK-ArrayList\ndate: 2014-08-09 20:59:33\ncategories: JDK源码\ntags: ['JDK', 'ArrayList']\ndescription: ArrayList 是最常用的容器类,内部实现是看名字就知道是用的数组,一直再用从来没有看过内部的实现细节,今天学习一下.\n---\nArrayList 是最常用的容器类,内部实现是看名字就知道是用的数组,一直再用从来没有看过内部的实现细节,今天学习一下.\n<!--more-->\n*ArrayList* 是最常用的容器类,内部实现是看名字就知道是用的数组,一直再用从来没有看过内部的实现细节,今天学习一下.\n打开 *ArrayList* 最开始的代码\n```java\nprivate transient Object[] elementData;\n```\n果然是通过数组来保存数据.    \n**transient** 是指明这个变量不要被序列化.\n\n###1.关于遍历  \n常用的遍历的方法就是创建迭代器\n```java\nIterator<String> it = list.iterator();\nwhile(it.hasNext()){\n    String s = it.next();\n}\n```  \n还有一种迭代器 *ListIterator* ,他继承了 *Iterator* ,除了有常规迭代器的方法还有 *hasPrevious()* 和 *previous()* 方法,提供了向前遍历.\n\n###2.ConcurrentModificationException\n在操作 *ArrayList* 时经常会发生 *ConcurrentModificationException* ,比如\n```java\nIterator<String> it = list.iterator();\nwhile(it.hasNext()){\n    String s = it.next();\n    list.remove(s); //list.add(s);\n}\n```\n在遍历 *ArrayList* 过程中执行移除或添加的操作就会抛出 *ConcurrentModificationException* .在 *ArrayList* 在父类 *AbstractList* 有一个变量 *modCount* ,这个值在 *ArrayList* 执行移除或者添加方法时会执行 *modCount++* 操作,在创建迭代器时 `Iterator<String> it = list.iterator();` 会把 *modCount* 传入到迭代器中并保存一份副本 `int expectedModCount = modCount;`,迭代器在遍历过程中调用 *next()* 方法时会执行\n```java\nfinal void checkForComodification() {\n\tif (modCount != expectedModCount)\n\t    throw new ConcurrentModificationException();\n    }\n}\n```\n因为在遍历过程中执行了移除或者添加方法,改变了 *modCount* 的值,所以 *modCount* 和 *expectedModCount* 不匹配,抛出 *ConcurrentModificationException* .  \n解决方案:  \n```java\nIterator<String> it = list.iterator();\nwhile(it.hasNext()){\n    String s = it.next();\n    it.remove(); \n}\n```\n将移除方法改为迭代器的移除方法,就不会抛出异常,因为 *it.remove()* 是通过当前的索引移除,并且在移除后会用最新的 *modCount* 更新 *expectedModCount* ,所以不会抛出异常.\n还有一种解决方案,是在遍历过程中将需要移除掉的元素保存到一个临时的ArrayList中,在遍历完成后,执行 *removeAll* 方法. \n\n###3.自动扩容  \nArrayList是没有长度限制的,但是他内部的存储结构是数组,数组是需要固定长度的.ArrayList在添加一个元素的时候会判断是否已经大于当前数组的长度,如果大于,会创建一个新的数组,长度是当前数组长度的1.5倍,再将当前数据复制到新数组中.  \n\n###4.UnsupportedOperationException\nUnsupportedOperationException这个异常也很常见,在 *ArrayList* 的父类 *AbstractList* 定义了很多方法,方法体就是抛出 *UnsupportedOperationException* ,如果子类没有重写这个方法,调用的时候就会抛出这个异常\n```java\npublic E remove(int index) {\n    throw new UnsupportedOperationException();\n}\n```\n这更像是一种编程技巧,可能会有这样一种场景,多个子类继承同一个父类,而子类之间的行为有可能不是全部相同或者说全部支持,通过上面这种方式处理,约定好一种 *exception* ,处理起来更加的优雅,易理解.","slug":"jdk-arraylist","updated":1407673860000,"excerpt":"<p>ArrayList 是最常用的容器类,内部实现是看名字就知道是用的数组,一直再用从来没有看过内部的实现细节,今天学习一下.\n","_id":"c5e3zeatuomrjnk1","comments":true,"layout":"post","photos":[],"link":""},{"title":"JDK-HashMap","date":1407673811000,"categories":["aidwn3fgrekq2svq"],"tags":["sj2ttyeugxvwc2gl","o2pk9tvg7dk7gj49"],"description":null,"content":"<p>HashMap 也是一个经常用到的集合类, 有几个很基础的特性, 比方说key和value支持NULL, 不是同步安全, 可以自动扩容等.\n<a id=\"more\"></a>\n<em>HashMap</em> 也是一个经常用到的集合类, 有几个很基础的特性, 比方说key和value支持NULL, 不是同步安全, 可以自动扩容等. 我们现在来看一下具体的代码.  </p>\n<h3 id=\"1.-存储结构\">1. 存储结构</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"javadoc\">/**</span></div><div class=\"line\">* The table, resized as necessary. Length MUST Always be a power of two.</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">transient</span> Entry&lt;K,V&gt;[] table;</div></pre></td></tr></table></figure>\n\n<p><em>HashMap</em> 在内部维护着 <em>Entry</em> 类型的数组, 所有需要保存的元素都是存储在这里的. <em>Entry</em> 是 <em>HashMap</em> 一个内部静态类, 他的结构很类似于链表, 这也决定了当 <em>HashMap</em> 去 <em>put</em> 一个元素, 发生碰撞时就是通过链表去解决的,后面会有详细的描述.<br><em>HashMap</em> 在初始化的时候会初始化几个值, 初始大小, 扩充因子, 以及阀值, 扩充因子决定了当 <em>HashMap</em> 阀值的大小, 当 <em>HashMap</em> 的容量超过阀值时会触发扩容的方法,固定扩容到当前大小的2倍. <em>HashMap</em> 是有最大容量限制的, 是2^32.</p>\n<h3 id=\"2.-put\">2. PUT</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span>(K key, V value) {</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);</div><div class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key);</div><div class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);</div><div class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) {</div><div class=\"line\">        Object k;</div><div class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash && ((k = e.key) == key || key.equals(k))) {</div><div class=\"line\">            V oldValue = e.value;</div><div class=\"line\">            e.value = value;</div><div class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span> oldValue;</div><div class=\"line\">        }</div><div class=\"line\">    }</div><div class=\"line\">    modCount++;</div><div class=\"line\">    addEntry(hash, key, value, i);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><em>HashMap</em> 单独对 <em>NULL</em> 的情况做了处理, 所以可以支持 <em>key</em> 或者 <em>value</em> 为 <em>NULL</em>. <strong><em>int hash = hash(key); int i = indexFor(hash, table.length);</em></strong> 这里计算这个 <em>key</em> 要放的位置的索引, 先是计算 <em>Hash值</em> , 再用 <em>Hash值</em> 和当前的长度做与运算计算出正确的位置(以前一直以为是取模原来是做的与运算).\n还需要注意一点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> addEntry(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex) {</div><div class=\"line\">    <span class=\"keyword\">if</span> ((size &gt;= threshold) && (<span class=\"keyword\">null</span> != table[bucketIndex])) {</div><div class=\"line\">        resize(<span class=\"number\">2</span> * table.length);</div><div class=\"line\">        hash = (<span class=\"keyword\">null</span> != key) ? hash(key) : <span class=\"number\">0</span>;</div><div class=\"line\">        bucketIndex = indexFor(hash, table.length);</div><div class=\"line\">    }</div><div class=\"line\">    createEntry(hash, key, value, bucketIndex);</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>在 <em>PUT</em> 元素到 <em>HashMap</em> 之前会先做一次容量的判断, 如果当前的容量超过阀值会触发扩容方法, 扩容方法会做2件事, 1是将当前 <em>Entry</em> 数组的容易扩大为2倍, 2将当前的数据迁移到新的 <em>Entry</em> 数组中. 然后会重新计算要 <em>PUT</em> 的位置索引值. 在 <em>PUT</em> 时, 如果当前位置已经有一个 <em>Entry</em> 了, 会把这个 <em>Entry</em> 取出来当做新 <em>Entry</em> 的下一个元素, 形成了一个链表. 整个的 <em>PUT</em> 方法是没有同步锁的, 而且计算位置与插入数据是分开的步骤去做的, 所以在并发的情况, 如果有个多线程同时在写就会发生计算的位置不准确的问题, 后面会实例代码.</p>\n<h3 id=\"3.-get\">3. GET</h3><p><em>GET</em> 方法相对没有那么复杂, 也是会对 <em>NULL</em> 进行特殊的处理. 在计算出位置的索引后, 如果取出的是一个链表还需要判断 <em>key</em> 是否相同.</p>\n<h3 id=\"4.-并发\">4. 并发</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>{</div><div class=\"line\">    <span class=\"keyword\">static</span> HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;(<span class=\"number\">10</span>);</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> COUNT = <span class=\"number\">10</span>;</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> CountDownLatch START_SIGNAL = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> CountDownLatch END_SIGNAL = <span class=\"keyword\">new</span> CountDownLatch(COUNT);</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> AtomicInteger count = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Runnable task = <span class=\"keyword\">new</span> Runnable(){</div><div class=\"line\">        <span class=\"annotation\">@Override</span></div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>() {</div><div class=\"line\">            <span class=\"keyword\">try</span> {</div><div class=\"line\">                START_SIGNAL.await();</div><div class=\"line\">            } <span class=\"keyword\">catch</span> (InterruptedException e) {</div><div class=\"line\">                e.printStackTrace();</div><div class=\"line\">            }</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++){</div><div class=\"line\">                map.put(i, i);</div><div class=\"line\">            }</div><div class=\"line\">            count.incrementAndGet();</div><div class=\"line\">            END_SIGNAL.countDown();</div><div class=\"line\">        }</div><div class=\"line\">    };</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(String[] args){</div><div class=\"line\">        ExecutorService services = Executors.newFixedThreadPool(COUNT);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;COUNT; i++){</div><div class=\"line\">            services.execute(task);</div><div class=\"line\">        }</div><div class=\"line\">        START_SIGNAL.countDown();</div><div class=\"line\">        <span class=\"keyword\">try</span> {</div><div class=\"line\">            END_SIGNAL.await();</div><div class=\"line\">            System.out.println(count.get() + <span class=\"string\">\" \"</span> + map.size());</div><div class=\"line\"></div><div class=\"line\">            Set&lt;Integer&gt; keySet = map.keySet();</div><div class=\"line\">            <span class=\"keyword\">for</span>(Integer key:keySet){</div><div class=\"line\">                Integer value = map.get(key);</div><div class=\"line\">                System.out.println(key + <span class=\"string\">\" \"</span> + value);</div><div class=\"line\">            }</div><div class=\"line\">        } <span class=\"keyword\">catch</span> (InterruptedException e) {</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        } <span class=\"keyword\">catch</span> (Exception ex){</div><div class=\"line\">            ex.printStackTrace();</div><div class=\"line\">        }</div><div class=\"line\">        services.shutdown();</div><div class=\"line\">    }</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Resul<span class=\"variable\">t:</span></div><div class=\"line\"><span class=\"number\">10</span> <span class=\"number\">13</span></div><div class=\"line\"><span class=\"number\">0</span> <span class=\"number\">0</span></div><div class=\"line\"><span class=\"number\">0</span> <span class=\"number\">0</span></div><div class=\"line\"><span class=\"number\">1</span> <span class=\"number\">1</span></div><div class=\"line\"><span class=\"number\">2</span> <span class=\"number\">2</span></div><div class=\"line\"><span class=\"number\">3</span> <span class=\"number\">3</span></div><div class=\"line\"><span class=\"number\">3</span> <span class=\"number\">3</span></div><div class=\"line\"><span class=\"number\">4</span> <span class=\"number\">4</span></div><div class=\"line\"><span class=\"number\">5</span> <span class=\"number\">5</span></div><div class=\"line\"><span class=\"number\">6</span> <span class=\"number\">6</span></div><div class=\"line\"><span class=\"number\">7</span> <span class=\"number\">7</span></div><div class=\"line\"><span class=\"number\">8</span> <span class=\"number\">8</span></div><div class=\"line\"><span class=\"number\">9</span> <span class=\"number\">9</span></div></pre></td></tr></table></figure>\n\n<p>看到中间会出现重复的key, 这就是出现问题了, 如果换成 <em>Hashtable</em> 就不会出现这个问题, 因为 <em>Hashtable</em> 的 <em>PUT</em> 方法添加了修饰符 <em>synchronized</em>.</p>\n","source":"_posts/jdk-hashmap.md","raw":"title: JDK-HashMap\ndate: 2014-08-10 20:30:11\ncategories: JDK源码\ntags: ['JDK', 'HashMap']\ndescription:\n---\nHashMap 也是一个经常用到的集合类, 有几个很基础的特性, 比方说key和value支持NULL, 不是同步安全, 可以自动扩容等.\n<!--more-->\n*HashMap* 也是一个经常用到的集合类, 有几个很基础的特性, 比方说key和value支持NULL, 不是同步安全, 可以自动扩容等. 我们现在来看一下具体的代码.  \n###1. 存储结构\n```java\n/**\n* The table, resized as necessary. Length MUST Always be a power of two.\n*/\ntransient Entry<K,V>[] table;\n```\n*HashMap* 在内部维护着 *Entry* 类型的数组, 所有需要保存的元素都是存储在这里的. *Entry* 是 *HashMap* 一个内部静态类, 他的结构很类似于链表, 这也决定了当 *HashMap* 去 *put* 一个元素, 发生碰撞时就是通过链表去解决的,后面会有详细的描述.  \n*HashMap* 在初始化的时候会初始化几个值, 初始大小, 扩充因子, 以及阀值, 扩充因子决定了当 *HashMap* 阀值的大小, 当 *HashMap* 的容量超过阀值时会触发扩容的方法,固定扩容到当前大小的2倍. *HashMap* 是有最大容量限制的, 是2^32.\n\n###2. PUT\n```java\npublic V put(K key, V value) {\n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);\n    int i = indexFor(hash, table.length);\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    modCount++;\n    addEntry(hash, key, value, i);\n    return null;\n}\n```\n*HashMap* 单独对 *NULL* 的情况做了处理, 所以可以支持 *key* 或者 *value* 为 *NULL*. ***int hash = hash(key); int i = indexFor(hash, table.length);*** 这里计算这个 *key* 要放的位置的索引, 先是计算 *Hash值* , 再用 *Hash值* 和当前的长度做与运算计算出正确的位置(以前一直以为是取模原来是做的与运算).\n还需要注意一点\n```java\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = indexFor(hash, table.length);\n    }\n    createEntry(hash, key, value, bucketIndex);\n}\n```\n在 *PUT* 元素到 *HashMap* 之前会先做一次容量的判断, 如果当前的容量超过阀值会触发扩容方法, 扩容方法会做2件事, 1是将当前 *Entry* 数组的容易扩大为2倍, 2将当前的数据迁移到新的 *Entry* 数组中. 然后会重新计算要 *PUT* 的位置索引值. 在 *PUT* 时, 如果当前位置已经有一个 *Entry* 了, 会把这个 *Entry* 取出来当做新 *Entry* 的下一个元素, 形成了一个链表. 整个的 *PUT* 方法是没有同步锁的, 而且计算位置与插入数据是分开的步骤去做的, 所以在并发的情况, 如果有个多线程同时在写就会发生计算的位置不准确的问题, 后面会实例代码.\n\n###3. GET\n*GET* 方法相对没有那么复杂, 也是会对 *NULL* 进行特殊的处理. 在计算出位置的索引后, 如果取出的是一个链表还需要判断 *key* 是否相同.\n\n###4. 并发\n```java\npublic class App {\n    static HashMap<Integer, Integer> map = new HashMap<Integer, Integer>(10);\n    final static int COUNT = 10;\n    final static CountDownLatch START_SIGNAL = new CountDownLatch(1);\n    final static CountDownLatch END_SIGNAL = new CountDownLatch(COUNT);\n    final static AtomicInteger count = new AtomicInteger(0);\n    final static Runnable task = new Runnable(){\n        @Override\n        public void run() {\n            try {\n                START_SIGNAL.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            for(int i=0; i<10; i++){\n                map.put(i, i);\n            }\n            count.incrementAndGet();\n            END_SIGNAL.countDown();\n        }\n    };\n    public static void main(String[] args){\n        ExecutorService services = Executors.newFixedThreadPool(COUNT);\n        for(int i=0; i<COUNT; i++){\n            services.execute(task);\n        }\n        START_SIGNAL.countDown();\n        try {\n            END_SIGNAL.await();\n            System.out.println(count.get() + \" \" + map.size());\n\n            Set<Integer> keySet = map.keySet();\n            for(Integer key:keySet){\n                Integer value = map.get(key);\n                System.out.println(key + \" \" + value);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (Exception ex){\n            ex.printStackTrace();\n        }\n        services.shutdown();\n    }\n}\n```\n```\nResult:\n10 13\n0 0\n0 0\n1 1\n2 2\n3 3\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\n```\n看到中间会出现重复的key, 这就是出现问题了, 如果换成 *Hashtable* 就不会出现这个问题, 因为 *Hashtable* 的 *PUT* 方法添加了修饰符 *synchronized*.\n","slug":"jdk-hashmap","updated":1407675224000,"excerpt":"<p>HashMap 也是一个经常用到的集合类, 有几个很基础的特性, 比方说key和value支持NULL, 不是同步安全, 可以自动扩容等.\n","_id":"m1tek6xoz1gh6t9a","comments":true,"layout":"post","photos":[],"link":""},{"title":"JVM-debug","date":1407675573000,"categories":["5w4csv955ihnptcs"],"tags":["afsblswislr1ay60","v609vlubu0bmuwgf"],"description":null,"content":"<p>大家都有过遇到线上程序LOAD突然狂飙的场景，要排查到为何狂飙，我们当务之急就是要找到导致CPU飙升的原因。如果是进程级的应用，如Nginx、Apache等都还比较容易排查，但如果是JVM中的某个线程导致的，估计有人就要开始抓瞎了。\n<a id=\"more\"></a>\n大家都有过遇到线上程序LOAD突然狂飙的场景，要排查到为何狂飙，我们当务之急就是要找到导致CPU飙升的原因。如果是进程级的应用，如Nginx、Apache等都还比较容易排查，但如果是JVM中的某个线程导致的，估计有人就要开始抓瞎了。<br>很多人都或多或少的知道有这么一个脚本，能帮你大致定位到现场导致LOAD飙升的JVM线程，脚本大概如下。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"shebang\">#!/bin/ksh</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">typeset</span> top=$\\{<span class=\"number\">1</span>:-<span class=\"number\">10</span>\\}</div><div class=\"line\"><span class=\"built_in\">typeset</span> pid=$\\{<span class=\"number\">2</span>:-$(pgrep -u <span class=\"variable\">$USER</span> java)\\}</div><div class=\"line\"><span class=\"built_in\">typeset</span> tmp_file=/tmp/java_$\\{pid\\}_$$.trace</div><div class=\"line\"> </div><div class=\"line\"><span class=\"variable\">$JAVA_HOME</span>/bin/jstack <span class=\"variable\">$pid</span> &gt; <span class=\"variable\">$tmp_file</span></div><div class=\"line\">ps H -eo user,pid,ppid,tid,time,%cpu --sort=%cpu --no-headers\\</div><div class=\"line\">        | tail -<span class=\"variable\">$top</span>\\</div><div class=\"line\">        | awk -v <span class=\"string\">\"pid=<span class=\"variable\">$pid</span>\"</span> <span class=\"string\">'$2==pid{print $4\"\\t\"$6}'</span>\\</div><div class=\"line\">        | <span class=\"keyword\">while</span> <span class=\"built_in\">read</span> line;</div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">        <span class=\"built_in\">typeset</span> nid=$(<span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$line</span>\"</span>|awk <span class=\"string\">'{printf(\"0x%x\",$1)}'</span>)</div><div class=\"line\">        <span class=\"built_in\">typeset</span> cpu=$(<span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$line</span>\"</span>|awk <span class=\"string\">'{print $2}'</span>)</div><div class=\"line\">        awk -v <span class=\"string\">\"cpu=<span class=\"variable\">$cpu</span>\"</span> <span class=\"string\">'/nid='</span><span class=\"string\">\"<span class=\"variable\">$nid</span>\"</span><span class=\"string\">'/,/^$/{print $0\"\\t\"(isF++?\"\":\"cpu=\"cpu\"%\");}'</span> <span class=\"variable\">$tmp_file</span></div><div class=\"line\"><span class=\"keyword\">done</span></div><div class=\"line\"> </div><div class=\"line\">rm <span class=\"operator\">-f</span> <span class=\"variable\">$tmp_file</span></div></pre></td></tr></table></figure>\n\n<p>现在我们就来拆解其中的原理，以及说明下类似脚本的适用范围。</p>\n<h4 id=\"步骤1：dump当前jvm线程，保存现场\">步骤1：dump当前JVM线程，保存现场</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"input\"><span class=\"prompt\">$JAVA_HOME/bin/jstack $pid &gt;</span> <span class=\"variable\">$tmp_file</span></span></div></pre></td></tr></table></figure>\n\n\n<p>保存现场是相当的重要，因为问题转瞬之间就会从手中溜走（但其实LOAD的统计机制也决定了，事实也并不是那么严格）</p>\n<h4 id=\"步骤2：找到当前cpu使用占比高的线程\">步骤2：找到当前CPU使用占比高的线程</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ps H -eo user,pid,ppid,tid,<span class=\"keyword\">time</span>,<span class=\"variable\">%cpu</span> --<span class=\"keyword\">sort</span>=<span class=\"variable\">%cpu</span></div></pre></td></tr></table></figure>\n\n<p><img src=\"http://img4.tbcdn.cn/L1/461/1/b_12679_1389500395_604324404.png\" alt=\"\"><br>列说明<br>USER：进程归属用户<br>PID：进程号<br>PPID：父进程号<br>TID：线程号<br>%CPU：线程使用CPU占比（这里要提醒下各位，这个CPU占比是通过/proc计算得到，存在时间差）</p>\n<h4 id=\"步骤3：合并相关信息\">步骤3：合并相关信息</h4><p>我们需要关注的大概是3列：PID、TID、%CPU，我们通过PS拿到了TID，可以通过进制换算10-16得到jstack出来的JVM线程号​</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">typeset</span> nid=<span class=\"string\">\"0x\"</span>$(<span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$line</span>\"</span>|awk <span class=\"string\">'{print $1}'</span>|xargs -I{} <span class=\"built_in\">echo</span> <span class=\"string\">\"obase=16;{}\"</span>|bc|tr <span class=\"string\">'A-Z'</span> <span class=\"string\">'a-z'</span>)</div></pre></td></tr></table></figure>\n\n<p><img src=\"http://img4.tbcdn.cn/L1/461/1/b_12679_1389501427_1335323358.png\" alt=\"\"> </p>\n<h4 id=\"适用范围说明\">适用范围说明</h4><p>看似这个脚本很牛X的样子，能直接定位到最耗费CPU的线程，开发再也不用担心找不到线上最有问题的代码～但，且慢，姑且注意下输出的结果，State: WAITING 这是这个啥节奏～<br>这是因为ps中的%CPU数据统计来自于/proc/stat，这个份数据并非实时的，而是取决于OS对其更新的频率，一般为1S。所以你看到的数据统计会和jstack出来的信息不一致也就是这个原因～但这份信息对持续LOAD由少数几个线程导致的问题排查还是非常给力的，因为这些固定少数几个线程会持续消耗CPU的资源，即使存在时间差，反正也都是这几个线程所导致。</p>\n","source":"_posts/jvm-debug.md","raw":"title: JVM-debug\ndate: 2014-08-10 20:59:33\ncategories: debug\ntags: ['JVM', 'debug']\ndescription:\n---\n大家都有过遇到线上程序LOAD突然狂飙的场景，要排查到为何狂飙，我们当务之急就是要找到导致CPU飙升的原因。如果是进程级的应用，如Nginx、Apache等都还比较容易排查，但如果是JVM中的某个线程导致的，估计有人就要开始抓瞎了。\n<!--more-->\n大家都有过遇到线上程序LOAD突然狂飙的场景，要排查到为何狂飙，我们当务之急就是要找到导致CPU飙升的原因。如果是进程级的应用，如Nginx、Apache等都还比较容易排查，但如果是JVM中的某个线程导致的，估计有人就要开始抓瞎了。   \n很多人都或多或少的知道有这么一个脚本，能帮你大致定位到现场导致LOAD飙升的JVM线程，脚本大概如下。\n```shell\n#!/bin/ksh\n \ntypeset top=$\\{1:-10\\}\ntypeset pid=$\\{2:-$(pgrep -u $USER java)\\}\ntypeset tmp_file=/tmp/java_$\\{pid\\}_$$.trace\n \n$JAVA_HOME/bin/jstack $pid > $tmp_file\nps H -eo user,pid,ppid,tid,time,%cpu --sort=%cpu --no-headers\\\n        | tail -$top\\\n        | awk -v \"pid=$pid\" '$2==pid{print $4\"\\t\"$6}'\\\n        | while read line;\ndo\n        typeset nid=$(echo \"$line\"|awk '{printf(\"0x%x\",$1)}')\n        typeset cpu=$(echo \"$line\"|awk '{print $2}')\n        awk -v \"cpu=$cpu\" '/nid='\"$nid\"'/,/^$/{print $0\"\\t\"(isF++?\"\":\"cpu=\"cpu\"%\");}' $tmp_file\ndone\n \nrm -f $tmp_file\n```\n现在我们就来拆解其中的原理，以及说明下类似脚本的适用范围。\n####步骤1：dump当前JVM线程，保存现场\n```shell\n$JAVA_HOME/bin/jstack $pid > $tmp_file \n```  \n保存现场是相当的重要，因为问题转瞬之间就会从手中溜走（但其实LOAD的统计机制也决定了，事实也并不是那么严格）\n####步骤2：找到当前CPU使用占比高的线程\n```shell \nps H -eo user,pid,ppid,tid,time,%cpu --sort=%cpu \n```\n![](http://img4.tbcdn.cn/L1/461/1/b_12679_1389500395_604324404.png)  \n列说明  \nUSER：进程归属用户  \nPID：进程号  \nPPID：父进程号  \nTID：线程号  \n%CPU：线程使用CPU占比（这里要提醒下各位，这个CPU占比是通过/proc计算得到，存在时间差）\n####步骤3：合并相关信息\n我们需要关注的大概是3列：PID、TID、%CPU，我们通过PS拿到了TID，可以通过进制换算10-16得到jstack出来的JVM线程号​\n```shell \ntypeset nid=\"0x\"$(echo \"$line\"|awk '{print $1}'|xargs -I{} echo \"obase=16;{}\"|bc|tr 'A-Z' 'a-z') \n```\n![](http://img4.tbcdn.cn/L1/461/1/b_12679_1389501427_1335323358.png) \n####适用范围说明\n看似这个脚本很牛X的样子，能直接定位到最耗费CPU的线程，开发再也不用担心找不到线上最有问题的代码～但，且慢，姑且注意下输出的结果，State: WAITING 这是这个啥节奏～  \n这是因为ps中的%CPU数据统计来自于/proc/stat，这个份数据并非实时的，而是取决于OS对其更新的频率，一般为1S。所以你看到的数据统计会和jstack出来的信息不一致也就是这个原因～但这份信息对持续LOAD由少数几个线程导致的问题排查还是非常给力的，因为这些固定少数几个线程会持续消耗CPU的资源，即使存在时间差，反正也都是这几个线程所导致。\n","slug":"jvm-debug","updated":1407675803000,"excerpt":"<p>大家都有过遇到线上程序LOAD突然狂飙的场景，要排查到为何狂飙，我们当务之急就是要找到导致CPU飙升的原因。如果是进程级的应用，如Nginx、Apache等都还比较容易排查，但如果是JVM中的某个线程导致的，估计有人就要开始抓瞎了。\n","_id":"2dg1cnc7qirpwv2z","comments":true,"layout":"post","photos":[],"link":""},{"title":"synchronized的简单用法","date":1407675841000,"categories":["o21o0hv3f03hdic4"],"tags":["r05dzop4f5o57e1b","0yvwyuq1przrk55i"],"description":null,"content":"<p>简单说明下synchronized常用的场景以及用法\n<a id=\"more\"></a>\nsynchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量).<br>有几个需要注意的地方</p>\n<ul>\n<li>无论synchronized关键字加在方法上还是对象上，他取得的锁都是对象，而不是把一段代码或函数当作锁,而且同步方法很可能还会被其他线程的对象访问。 </li>\n<li>每个对象只有一个锁（lock）和之相关联。 </li>\n<li><p>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。  </p>\n</li>\n<li><p><strong>把synchronized当作函数修饰符时</strong>  </p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span>(){   </div><div class=\"line\">    <span class=\"comment\">//......  </span></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>他锁定的是调用这个同步方法对象。也就是说，当一个对象P1在不同的线程中执行这个同步方法时，他们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却能够任意调用这个被加了synchronized关键字的方法。<br>上边的示例代码等同于如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span>() {   </div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>){      <span class=\"comment\">//  (a)     </span></div><div class=\"line\">     <span class=\"comment\">//......  </span></div><div class=\"line\">    }   </div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>(a)处的this指的是什么呢？他指的就是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。那个拿到了P1对象锁的线程，才能够调用P1的同步方法，而对P2而言，P1这个锁和他毫不相干，程式也可能在这种情形下摆脱同步机制的控制，造成数据混乱。  </p>\n<ol>\n<li><strong>同步块</strong>  </li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span>(SomeObject so) {   </div><div class=\"line\"> <span class=\"keyword\">synchronized</span>(so) {   </div><div class=\"line\">  <span class=\"comment\">//......   </span></div><div class=\"line\"> }   </div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>这时，锁就是so这个对象，谁拿到这个锁谁就能够运行他所控制的那段代码。当有一个明确的对象作为锁时，就能够这样写程式，但当没有明确的对象作为锁，只是想让一段代码同步时，能够创建一个特别的instance变量（他得是个对象）来充当锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Foo implements Runnable{   </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] lock = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">0</span>];  <span class=\"comment\">// 特别的instance变量   </span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span>() {   </div><div class=\"line\">        <span class=\"keyword\">synchronized</span>(lock) { <span class=\"comment\">//...... }   </span></div><div class=\"line\">    }   </div><div class=\"line\">\t<span class=\"comment\">//......   </span></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><strong>注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。</strong></p>\n<ol>\n<li><strong>将synchronized作用于static函数</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Foo {   </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span>(){   <span class=\"comment\">// 同步的static 函数      </span></div><div class=\"line\">  <span class=\"comment\">//......   </span></div><div class=\"line\"> }   </div><div class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span>(){   </div><div class=\"line\">        <span class=\"keyword\">synchronized</span>(Foo.class)   <span class=\"comment\">//  class literal(类名称字面常量)   </span></div><div class=\"line\"> }   </div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;代码中的method2()方法是把class literal作为锁的情况，他和同步的static函数产生的效果是相同的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）.<br>&emsp;&emsp;记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不相同，不能用P1.getClass()来达到锁这个Class的目的。P1指的是由Foo类产生的对象。<br>&emsp;&emsp;能够推断：假如一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为他们的锁都不相同。A方法的锁是Obj所属的那个Class，而B的锁是Obj所属的这个对象。</p>\n","source":"_posts/synchronized.md","raw":"title: synchronized的简单用法\ndate: 2014-08-10 21:04:01\ncategories: java\ntags: ['synchronized', 'java']\ndescription:\n---\n简单说明下synchronized常用的场景以及用法\n<!--more-->\nsynchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量).  \n有几个需要注意的地方\n- 无论synchronized关键字加在方法上还是对象上，他取得的锁都是对象，而不是把一段代码或函数当作锁,而且同步方法很可能还会被其他线程的对象访问。 \n- 每个对象只有一个锁（lock）和之相关联。 \n- 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。  \n\n1. **把synchronized当作函数修饰符时**  \n    ```java\n    public synchronized void method(){   \n        //......  \n    } \n    ```\n他锁定的是调用这个同步方法对象。也就是说，当一个对象P1在不同的线程中执行这个同步方法时，他们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却能够任意调用这个被加了synchronized关键字的方法。  \n上边的示例代码等同于如下代码：\n```java\n    public void method() {   \n        synchronized (this){      //  (a)     \n\t        //......  \n        }   \n    }   \n```\n(a)处的this指的是什么呢？他指的就是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。那个拿到了P1对象锁的线程，才能够调用P1的同步方法，而对P2而言，P1这个锁和他毫不相干，程式也可能在这种情形下摆脱同步机制的控制，造成数据混乱。  \n\n2. **同步块**  \n```java\n    public void method(SomeObject so) {   \n\t    synchronized(so) {   \n\t\t    //......   \n\t    }   \n    } \n```\n这时，锁就是so这个对象，谁拿到这个锁谁就能够运行他所控制的那段代码。当有一个明确的对象作为锁时，就能够这样写程式，但当没有明确的对象作为锁，只是想让一段代码同步时，能够创建一个特别的instance变量（他得是个对象）来充当锁：\n```java\n    class Foo implements Runnable{   \n        private byte[] lock = new byte[0];  // 特别的instance变量   \n        public void method() {   \n            synchronized(lock) { //...... }   \n        }   \n    \t//......   \n    }\n```\n**注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。**\n\n3. **将synchronized作用于static函数**\n```java\n    class Foo {   \n        public synchronized static void method1(){   // 同步的static 函数      \n\t\t    //......   \n\t    }   \n\t    public void method2(){   \n            synchronized(Foo.class)   //  class literal(类名称字面常量)   \n\t    }   \n    }   \n```\n&emsp;&emsp;代码中的method2()方法是把class literal作为锁的情况，他和同步的static函数产生的效果是相同的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）.  \n&emsp;&emsp;记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不相同，不能用P1.getClass()来达到锁这个Class的目的。P1指的是由Foo类产生的对象。   \n&emsp;&emsp;能够推断：假如一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为他们的锁都不相同。A方法的锁是Obj所属的那个Class，而B的锁是Obj所属的这个对象。\n","slug":"synchronized","updated":1407676355000,"excerpt":"<p>简单说明下synchronized常用的场景以及用法\n","_id":"c2g2vyr66rge2l1o","comments":true,"layout":"post","photos":[],"link":""},{"title":"github初级操作(小笨蛋版本)","date":1407740233000,"categories":["ldtfzc8g3ibrgv87"],"tags":["9qjvgiqmtwq9zh90","cij4ynsmh5d06mr4"],"description":null,"content":"<p>github的初级操作,适用于单人使用基本的git命令操作远程github.<br><a id=\"more\"></a>  </p>\n<h3 id=\"步骤1:-登录github创建一个新的repository\">步骤1: 登录GitHub创建一个新的repository</h3><h3 id=\"步骤2:-将repository克隆到本地\">步骤2: 将repository克隆到本地</h3><p>找到新创建的repository, 复制SSH的URL, 打开命令行窗口输入命令    </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">git</span> clone git<span class=\"variable\">@github</span>.com:keainono/keainono.github.io.git</div></pre></td></tr></table></figure>\n\n\n<p>现在在本地有了一个映射到GitHub远程的空的repository.  </p>\n<h3 id=\"步骤3:-操作本地repository\">步骤3: 操作本地repository</h3><p>进入本地的repository, 增加或者修改一些文件  </p>\n<h3 id=\"步骤4:-提交\">步骤4: 提交</h3><p>打开命令行窗口</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add <span class=\"keyword\">*</span> <span class=\"comment\">#这里的*是通配符,是指所有文件,也可以换成具体的文件名</span></div><div class=\"line\">git commit -m <span class=\"string\">\"BALABALA...\"</span> <span class=\"comment\">#注意,这里引号里的备注内容不可以为空,必须要填,否则会提交失败</span></div></pre></td></tr></table></figure>\n\n<h3 id=\"步骤5:-提交到远程repository\">步骤5: 提交到远程repository</h3><p>以上的操作只是在维护本地的版本,没有提交到远程的仓库,也就是说远程的仓库还是旧的,现在提交到远程</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"keyword\">push</span> origin master <span class=\"comment\">#origin是远程仓库默认的别名, master指的是远程的仓库的主干, 类似于svn的trunk</span></div></pre></td></tr></table></figure>\n\n<h3 id=\"小笨蛋看懂了吗-^o^\">小笨蛋看懂了吗 ^o^</h3>","source":"_posts/git-beginner.md","raw":"title: github初级操作(小笨蛋版本)\ndate: 2014-08-11 14:57:13\ncategories: git\ntags: ['git', 'github']\ndescription:\n---\ngithub的初级操作,适用于单人使用基本的git命令操作远程github.  \n<!--more-->  \n###步骤1: 登录GitHub创建一个新的repository### \n###步骤2: 将repository克隆到本地###    \n找到新创建的repository, 复制SSH的URL, 打开命令行窗口输入命令    \n```\ngit clone git@github.com:keainono/keainono.github.io.git \n```  \n现在在本地有了一个映射到GitHub远程的空的repository.  \n###步骤3: 操作本地repository###  \n进入本地的repository, 增加或者修改一些文件  \n###步骤4: 提交###  \n打开命令行窗口\n```\ngit add * #这里的*是通配符,是指所有文件,也可以换成具体的文件名\ngit commit -m \"BALABALA...\" #注意,这里引号里的备注内容不可以为空,必须要填,否则会提交失败\n```\n###步骤5: 提交到远程repository###\n以上的操作只是在维护本地的版本,没有提交到远程的仓库,也就是说远程的仓库还是旧的,现在提交到远程\n```\ngit push origin master #origin是远程仓库默认的别名, master指的是远程的仓库的主干, 类似于svn的trunk\n```\n\n\n###小笨蛋看懂了吗 ^o^ ###\n\n","slug":"git-beginner","updated":1407741065000,"excerpt":"<p>github的初级操作,适用于单人使用基本的git命令操作远程github.<br>","_id":"msxa3ng45s6qx6eq","comments":true,"layout":"post","photos":[],"link":""},{"title":"数据结构-树(基础)","date":1413886935000,"categories":["qrcv19hmxcf2i3as"],"tags":["e4vvunutehcr92ke","tl2fo7lvw4vsrpl3","rycfz0hp1py2n57x"],"description":null,"content":"<p>对数据结构中的树的基础理解,涉及到了二叉树的最基本的几种形态,满二叉树,完全二叉树,霍夫曼树以及遍历等相关知识点.\n<a id=\"more\"></a>\n<img src=\"http://boomya-files.qiniudn.com/IMAG0295.jpg\" alt=\"思维导图\"></p>\n","source":"_posts/data-structure-tree-basic.md","raw":"title: 数据结构-树(基础)\ndate: 2014-10-21 18:22:15\ncategories: 数据结构\ntags: ['树', '二叉树2', '霍夫曼树']\ndescription:\n---\n对数据结构中的树的基础理解,涉及到了二叉树的最基本的几种形态,满二叉树,完全二叉树,霍夫曼树以及遍历等相关知识点.\n<!--more-->\n![思维导图](http://boomya-files.qiniudn.com/IMAG0295.jpg)\n","slug":"data-structure-tree-basic","updated":1413888268000,"excerpt":"<p>对数据结构中的树的基础理解,涉及到了二叉树的最基本的几种形态,满二叉树,完全二叉树,霍夫曼树以及遍历等相关知识点.\n","_id":"f9f0q2bjn5a7jc3n","comments":true,"layout":"post","photos":[],"link":""},{"title":"linux基本命令","date":1419839823000,"categories":["5g0484d7oash73he"],"tags":["8v43p60c5b1rawb6","yk9oa7dhoft4e7c3","jgrzd510189eizmo"],"description":null,"content":"<p>linux下必须要掌握的基本命令\n<a id=\"more\"></a>\nv3</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">chmod</span> +<span class=\"keyword\">x</span> * <span class=\"comment\">#给当前所有脚本赋予执行权限, 使用ll查询当前权限</span></div><div class=\"line\">jps -mlv</div><div class=\"line\">ps -ef | <span class=\"keyword\">grep</span> java</div><div class=\"line\">netstat -anp | <span class=\"keyword\">grep</span> <span class=\"number\">8080</span></div><div class=\"line\">vmstat <span class=\"number\">1</span> <span class=\"number\">30</span> <span class=\"comment\">#每秒输出一次输出30次, r运行队列(说多少个进程真的分配到CPU), b被阻塞的进程</span></div><div class=\"line\">iostat -dxk <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"comment\">#查看IO相关性能值</span></div><div class=\"line\"><span class=\"comment\">#avgqu-sz:  平均I/O队列长度。</span></div><div class=\"line\"><span class=\"comment\">#await:  平均每次设备I/O操作的等待时间 (毫秒)。</span></div><div class=\"line\"><span class=\"comment\">#svctm: 平均每次设备I/O操作的服务时间 (毫秒)。</span></div><div class=\"line\"><span class=\"comment\">#%util:  一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</span></div><div class=\"line\"><span class=\"comment\">#如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。如果avgqu-sz比较大，也表示有大量io在等待。</span></div><div class=\"line\">ifstat <span class=\"comment\">#查看网卡当前流量,读入(in), 出口(out)</span></div><div class=\"line\">top -Hp <span class=\"number\">20943</span></div><div class=\"line\">ps -mp <span class=\"number\">20943</span> -o THREAD,tid <span class=\"comment\">#查找最耗CPU的线程</span></div><div class=\"line\"><span class=\"keyword\">printf</span> <span class=\"string\">\"<span class=\"variable\">%x</span>\\n\"</span> <span class=\"number\">21742</span> <span class=\"comment\">#10进制转16进制</span></div><div class=\"line\">jstack <span class=\"number\">20943</span> | <span class=\"keyword\">grep</span> <span class=\"number\">5</span>dee <span class=\"comment\">#输出指定线程的栈信息</span></div><div class=\"line\">jmap -heap <span class=\"number\">20943</span> <span class=\"comment\">#输出堆内存信息</span></div><div class=\"line\">jmap -histo:live <span class=\"number\">20943</span> <span class=\"comment\">#输出活着的对象数目. </span></div><div class=\"line\">B  byte</div><div class=\"line\">C  char</div><div class=\"line\">D  double</div><div class=\"line\">F  float</div><div class=\"line\">I  <span class=\"keyword\">int</span></div><div class=\"line\">J  long</div><div class=\"line\">Z  boolean</div><div class=\"line\">[  数组，如[I表示<span class=\"keyword\">int</span>[]</div><div class=\"line\">[L+类名 其他对象</div><div class=\"line\">jmap -<span class=\"keyword\">dump</span>:<span class=\"keyword\">format</span>=b,file=<span class=\"regexp\">/tmp/dump</span>.dat <span class=\"number\">21711</span></div><div class=\"line\">jstat -gc <span class=\"number\">20943</span> <span class=\"number\">250</span> <span class=\"number\">4</span> <span class=\"comment\">#每隔250秒取样1次.取4次</span></div><div class=\"line\">S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT  </div><div class=\"line\">S0C、S1C、S0U、S1U：Survivor <span class=\"number\">0</span>/<span class=\"number\">1</span>区容量（Capacity）和使用量（Used）</div><div class=\"line\">EC、EU：Eden区容量和使用量</div><div class=\"line\">OC、OU：年老代容量和使用量</div><div class=\"line\">PC、PU：永久代容量和使用量</div><div class=\"line\">YGC、YGT：年轻代GC次数和GC耗时</div><div class=\"line\">FGC、FGCT：Full GC次数和Full GC耗时</div><div class=\"line\">GCT：GC总耗时</div></pre></td></tr></table></figure>\n\n\n","source":"_posts/linux-basic-command.md","raw":"title: linux基本命令\ndate: 2014-12-29 15:57:03\ncategories: linux\ntags: ['linux', 'command', '日常']\ndescription:\n---\nlinux下必须要掌握的基本命令\n<!--more-->\nv3\n```shell\nchmod +x * #给当前所有脚本赋予执行权限, 使用ll查询当前权限\njps -mlv\nps -ef | grep java\nnetstat -anp | grep 8080\nvmstat 1 30 #每秒输出一次输出30次, r运行队列(说多少个进程真的分配到CPU), b被阻塞的进程\niostat -dxk 1 1 #查看IO相关性能值\n#avgqu-sz:  平均I/O队列长度。\n#await:  平均每次设备I/O操作的等待时间 (毫秒)。\n#svctm: 平均每次设备I/O操作的服务时间 (毫秒)。\n#%util:  一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比\n#如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。如果avgqu-sz比较大，也表示有大量io在等待。\nifstat #查看网卡当前流量,读入(in), 出口(out)\ntop -Hp 20943\nps -mp 20943 -o THREAD,tid #查找最耗CPU的线程\nprintf \"%x\\n\" 21742 #10进制转16进制\njstack 20943 | grep 5dee #输出指定线程的栈信息\njmap -heap 20943 #输出堆内存信息\njmap -histo:live 20943 #输出活着的对象数目. \nB  byte\nC  char\nD  double\nF  float\nI  int\nJ  long\nZ  boolean\n[  数组，如[I表示int[]\n[L+类名 其他对象\njmap -dump:format=b,file=/tmp/dump.dat 21711\njstat -gc 20943 250 4 #每隔250秒取样1次.取4次\nS0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT  \nS0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）\nEC、EU：Eden区容量和使用量\nOC、OU：年老代容量和使用量\nPC、PU：永久代容量和使用量\nYGC、YGT：年轻代GC次数和GC耗时\nFGC、FGCT：Full GC次数和Full GC耗时\nGCT：GC总耗时 \n``` \n","slug":"linux-basic-command","updated":1419844984000,"excerpt":"<p>linux下必须要掌握的基本命令\n","_id":"kpmeb3fnsx1fm3wl","comments":true,"layout":"post","photos":[],"link":""},{"title":"箴言","date":1419844828000,"categories":["uuf685eign7h5noh"],"tags":["jgrzd510189eizmo"],"description":null,"content":"<p>每天读一遍\n<a id=\"more\"></a></p>\n<h4 id=\"1.-一念放下,万般自在\">1. 一念放下,万般自在</h4><h4 id=\"2.-像个男人一样去做。\">2. 像个男人一样去做。</h4><h4 id=\"3.-当你对成功的渴望就像窒息时对呼吸的渴望，那你离成功不远了。\">3. 当你对成功的渴望就像窒息时对呼吸的渴望，那你离成功不远了。</h4><h4 id=\"4.-停止抱怨，加油吧。\">4. 停止抱怨，加油吧。</h4><h4 id=\"5.-发脾气是无能的表现。\">5. 发脾气是无能的表现。</h4><h4 id=\"6.-责人先责己，事事怨他人，反衬着你的无能。没有人愿意听你的牢骚，他们只需要结果，任何事情，结果最重要。\">6. 责人先责己，事事怨他人，反衬着你的无能。没有人愿意听你的牢骚，他们只需要结果，任何事情，结果最重要。</h4><h4 id=\"7.-每天2小时，改变人生\">7. 每天2小时，改变人生</h4><h4 id=\"8.-保持空杯状态，接受新语言\">8. 保持空杯状态，接受新语言</h4><h4 id=\"9.-找回当初软件开发的激情\">9. 找回当初软件开发的激情</h4><h4 id=\"10.-宁为狮尾，不做狐头\">10. 宁为狮尾，不做狐头</h4><h4 id=\"11.-要有信心，要坚强，要坚韧\">11. 要有信心，要坚强，要坚韧</h4><h4 id=\"12.-细节是魔鬼\">12. 细节是魔鬼</h4><h4 id=\"13.-provide-options,don&#39;t-make-lame-excuses.\">13. Provide options,don&#39;t make lame excuses.</h4><h4 id=\"提供各种选择，不要找蹩脚的借口.\">提供各种选择，不要找蹩脚的借口.</h4><h4 id=\"14.-规划好你想说的东西，写出大纲，然后问你：&quot;这是否讲清了我想要说的所有内容？&quot;提炼它，直到确实如此为止。\">14. 规划好你想说的东西，写出大纲，然后问你：&quot;这是否讲清了我想要说的所有内容？&quot;提炼它，直到确实如此为止。</h4>","source":"_posts/zhenyan.md","raw":"title: 箴言\ndate: 2014-12-29 17:20:28\ncategories: other\ntags: ['日常']\ndescription:\n---\n每天读一遍\n<!--more-->\n#### 1. 一念放下,万般自在  \n#### 2. 像个男人一样去做。\n#### 3. 当你对成功的渴望就像窒息时对呼吸的渴望，那你离成功不远了。\n#### 4. 停止抱怨，加油吧。\n#### 5. 发脾气是无能的表现。\n#### 6. 责人先责己，事事怨他人，反衬着你的无能。没有人愿意听你的牢骚，他们只需要结果，任何事情，结果最重要。\n#### 7. 每天2小时，改变人生\n#### 8. 保持空杯状态，接受新语言\n#### 9. 找回当初软件开发的激情\n#### 10. 宁为狮尾，不做狐头\n#### 11. 要有信心，要坚强，要坚韧\n#### 12. 细节是魔鬼\n#### 13. Provide options,don't make lame excuses.\n####提供各种选择，不要找蹩脚的借口.\n#### 14. 规划好你想说的东西，写出大纲，然后问你：\"这是否讲清了我想要说的所有内容？\"提炼它，直到确实如此为止。\n","slug":"zhenyan","updated":1419844965000,"excerpt":"<p>每天读一遍\n","_id":"vlqynib06xh6tpu9","comments":true,"layout":"post","photos":[],"link":""},{"title":"2014推荐图书","date":1419859353000,"categories":["rkc7hxpno7dbhfbc"],"tags":["h41se8u2i609ucds"],"description":null,"content":"<p>2014推荐图书\n<a id=\"more\"></a></p>\n<h3 id=\"开发\">开发</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">书名</th>\n<th style=\"text-align:left\">点评  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>高效能程序员的修炼</strong></td>\n<td style=\"text-align:left\">一位技术牛人在博客上关于编程的方方面面的文章集合，有见地，接地气。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>编写可读代码的艺术</strong></td>\n<td style=\"text-align:left\">简单实用，代码质量提升一个等级。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>软件开发者路线图</strong></td>\n<td style=\"text-align:left\">并不是严谨意义的路线图，是一系列软技能的模式。每个模式有情景分析，问题描述,解决办法，行动指南。实用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>高效程序员的45个习惯</strong></td>\n<td style=\"text-align:left\">列举了好的和坏的做法，风趣幽默。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"杂类\">杂类</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">书名</th>\n<th style=\"text-align:left\">点评  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>逆转</strong></td>\n<td style=\"text-align:left\">无   </td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>思考，快与慢</strong></td>\n<td style=\"text-align:left\">无 </td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>失控 : 全人类的最终命运和结局</strong></td>\n<td style=\"text-align:left\">KK在90年代预测全人类的最终命运，NB得不得了。对网络的发展也很有借鉴意义，作者被小马哥奉为座上宾。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>演说心理学 : 让你更有吸引力、说服力和影响力**</strong></td>\n<td style=\"text-align:left\">PPT和演说“集大成者”。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>乔布斯的魔力演讲</strong></td>\n<td style=\"text-align:left\">PPT和演讲中的TOP 1。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>高效能人士的思维导图</strong></td>\n<td style=\"text-align:left\">从实例中讲如何提高效率，很有操作性。讲的是思维，跟导图没有一毛钱关系。</td>\n</tr>\n</tbody>\n</table>\n","source":"_posts/2014-books.md","raw":"title: 2014推荐图书\ndate: 2014-12-29 21:22:33\ncategories: book\ntags: ['book']\ndescription:\n---\n2014推荐图书\n<!--more-->\n### 开发\n书名 | 点评  \n:----- | :-----\n**高效能程序员的修炼** | 一位技术牛人在博客上关于编程的方方面面的文章集合，有见地，接地气。\n**编写可读代码的艺术** | 简单实用，代码质量提升一个等级。\n**软件开发者路线图** | 并不是严谨意义的路线图，是一系列软技能的模式。每个模式有情景分析，问题描述,解决办法，行动指南。实用。\n**高效程序员的45个习惯** | 列举了好的和坏的做法，风趣幽默。\n\n### 杂类\n书名 | 点评  \n:----- | :-----\n**逆转** |  无   \n**思考，快与慢** | 无 \n**失控 : 全人类的最终命运和结局** |  KK在90年代预测全人类的最终命运，NB得不得了。对网络的发展也很有借鉴意义，作者被小马哥奉为座上宾。\n**演说心理学 : 让你更有吸引力、说服力和影响力**** | PPT和演说“集大成者”。\n**乔布斯的魔力演讲** | PPT和演讲中的TOP 1。\n**高效能人士的思维导图** | 从实例中讲如何提高效率，很有操作性。讲的是思维，跟导图没有一毛钱关系。\n\n\n","slug":"2014-books","updated":1419859942000,"excerpt":"<p>2014推荐图书\n","_id":"9syodqumwlg1ket0","comments":true,"layout":"post","photos":[],"link":""}],"Tag":[{"name":"JDK","_id":"sj2ttyeugxvwc2gl","posts":["c5e3zeatuomrjnk1","m1tek6xoz1gh6t9a"]},{"name":"ArrayList","_id":"pbsree1n4e3x1qlf","posts":["c5e3zeatuomrjnk1"]},{"name":"HashMap","_id":"o2pk9tvg7dk7gj49","posts":["m1tek6xoz1gh6t9a"]},{"name":"JVM","_id":"afsblswislr1ay60","posts":["2dg1cnc7qirpwv2z"]},{"name":"debug","_id":"v609vlubu0bmuwgf","posts":["2dg1cnc7qirpwv2z"]},{"name":"synchronized","_id":"r05dzop4f5o57e1b","posts":["c2g2vyr66rge2l1o"]},{"name":"java","_id":"0yvwyuq1przrk55i","posts":["c2g2vyr66rge2l1o"]},{"name":"git","_id":"9qjvgiqmtwq9zh90","posts":["msxa3ng45s6qx6eq"]},{"name":"github","_id":"cij4ynsmh5d06mr4","posts":["msxa3ng45s6qx6eq"]},{"name":"树","_id":"e4vvunutehcr92ke","posts":["f9f0q2bjn5a7jc3n"]},{"name":"二叉树2","_id":"tl2fo7lvw4vsrpl3","posts":["f9f0q2bjn5a7jc3n"]},{"name":"霍夫曼树","_id":"rycfz0hp1py2n57x","posts":["f9f0q2bjn5a7jc3n"]},{"name":"linux","_id":"8v43p60c5b1rawb6","posts":["kpmeb3fnsx1fm3wl"]},{"name":"command","_id":"yk9oa7dhoft4e7c3","posts":["kpmeb3fnsx1fm3wl"]},{"name":"日常","_id":"jgrzd510189eizmo","posts":["kpmeb3fnsx1fm3wl","vlqynib06xh6tpu9"]},{"name":"book","_id":"h41se8u2i609ucds","posts":["9syodqumwlg1ket0"]}]}